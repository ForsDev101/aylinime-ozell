<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Aylin'ime â€” SÃ¼rpriz</title>
<style>
  html,body { height:100%; margin:0; background:#000; font-family: "Press Start 2P", monospace; }
  canvas { display:block; width:100%; height:100vh; }
  /* Ã¼st yazÄ± */
  #hint {
    position: absolute;
    top: 8vh;
    width:100%;
    text-align:center;
    color:#ff9bcf;
    font-weight:700;
    letter-spacing:6px;
    font-size:18px;
    user-select:none;
    pointer-events:none;
    text-shadow: 0 0 12px #ff4d9e;
    font-family: monospace;
  }
  /* kapÄ± iÃ§in DOM elementi */
  #door {
    position:absolute;
    width:120px;
    height:160px;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%) scale(0.001);
    background:linear-gradient(180deg,#6b2a7e,#3c0f3f);
    border:6px solid #2b0a2b;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 8px 40px rgba(255,0,150,0.08);
    cursor:pointer;
    transition: transform 600ms cubic-bezier(.2,.9,.3,1);
    z-index:20;
    overflow:visible;
  }
  #door.opening { transform: translate(-50%,-50%) scale(1) rotateY(-100deg); transition: transform 900ms cubic-bezier(.2,.9,.3,1); transform-origin: left center; }
  #doorLabel {
    position:absolute;
    top:-36px;
    left:50%;
    transform:translateX(-50%);
    color:#ffd6f0;
    background:transparent;
    font-size:14px;
    letter-spacing:1px;
    text-shadow: 0 0 6px #ff7fb7;
    pointer-events:none;
  }
  /* emoji */
  #emoji {
    position:absolute;
    font-size:48px;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%) scale(0);
    z-index:21;
    transition: transform 800ms cubic-bezier(.2,.9,.3,1), left 900ms linear, top 900ms linear;
    filter: drop-shadow(0 8px 20px rgba(0,0,0,0.7));
  }
  /* konuÅŸma balonu (pixel-look) */
  #bubble {
    position:absolute;
    left:50%;
    top:calc(50% + 120px);
    transform:translateX(-50%) scale(0.001);
    background:#ffd9ec;
    color:#6b0a3a;
    padding:12px 18px;
    font-family: monospace;
    font-size:12px;
    border-radius:8px;
    border:4px solid #ff9bcf;
    z-index:22;
    box-shadow: 0 12px 40px rgba(255,72,147,0.08);
    letter-spacing:1px;
  }
  /* pixel look: small square overlay */
  .pixel-grid {
    image-rendering: pixelated;
  }
  /* son yazÄ± */
  #finalText {
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%) scale(0.001);
    color:#fff;
    font-size:64px;
    letter-spacing:8px;
    text-align:center;
    z-index:50;
    text-shadow: 0 0 40px #ff5aa3, 0 0 80px #ff2d93;
    font-weight:800;
    pointer-events:none;
    font-family: monospace;
  }

  @media (max-width:520px){
    #door { width:90px; height:120px; }
    #doorLabel { font-size:12px; top:-32px; }
    #bubble { font-size:11px; padding:8px 12px; top: calc(50% + 100px); }
    #finalText { font-size:36px; letter-spacing:4px; }
  }
</style>
</head>
<body>
  <div id="hint">Kalbe tÄ±klamaya ne dersin?</div>
  <canvas id="c"></canvas>

  <div id="door" style="display:none;">
    <div id="doorLabel">KapÄ± Ã§alÄ±yor, aÃ§mayacak mÄ±sÄ±n?</div>
  </div>

  <div id="emoji">ðŸ˜„ðŸŒ¹</div>
  <div id="bubble"></div>
  <div id="finalText">Aylin'ime</div>

<script>
/*
  Tek dosyada interaktif animasyon:
  - Pixel pembe kalp (canvas) -> tÄ±klanÄ±r
  - Patlama: parÃ§acÄ±klar etrafa daÄŸÄ±lÄ±r
  - ParÃ§acÄ±klar bir araya gelip bÃ¼yÃ¼k kalp oluÅŸturur (heart parametric)
  - KapÄ± DOM elemanÄ± belirir; tÄ±klanÄ±nca kapÄ± animasyonu + knock sesi
  - Emoji Ã§Ä±kar, kapÄ± kaybolur; konuÅŸma balonu pixel yazÄ± ile "Bu senin iÃ§in bitanem."
  - ~9s sonra pembe patlama ve bÃ¼yÃ¼k "Aylin'ime" yazÄ±sÄ±
*/

// helpers
const rand = (a,b) => a + Math.random()*(b-a);

// canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
const DPR = window.devicePixelRatio || 1;
canvas.width = innerWidth * DPR;
canvas.height = innerHeight * DPR;
canvas.style.width = innerWidth + 'px';
canvas.style.height = innerHeight + 'px';
ctx.scale(DPR, DPR);

// state
let particles = [];
let phase = 'idle'; // idle -> exploded -> forming -> formed -> doorShown -> doorOpen -> emojiOut -> bubble -> finale
const center = { x: innerWidth/2, y: innerHeight/2 };
const pixelSize = 10; // initial pixel heart block size
const initialHeartScale = Math.min(innerWidth, innerHeight) * 0.12;

// create initial pixel heart via implicit function sampling
function pointInHeart(nx, ny) {
  // implicit heart: (x^2 + y^2 -1)^3 - x^2 y^3 <= 0
  const x = nx;
  const y = ny;
  return Math.pow(x*x + y*y - 1, 3) - x*x*y*y*y <= 0;
}
function buildInitialParticles() {
  particles = [];
  const gridW = Math.floor(initialHeartScale / pixelSize) * 2;
  const gridH = Math.floor(initialHeartScale / pixelSize) * 2;
  // iterate grid around center
  for (let gx = -gridW/2; gx < gridW/2; gx++) {
    for (let gy = -gridH/2; gy < gridH/2; gy++) {
      // normalize to [-1.5,1.5] roughly
      const nx = gx / (gridW/4);
      const ny = gy / (gridH/4);
      if (pointInHeart(nx, ny)) {
        const x = center.x + gx * pixelSize + rand(-2,2);
        const y = center.y + gy * pixelSize + rand(-2,2);
        particles.push({
          x, y,
          ox: x, oy: y,
          vx:0, vy:0,
          size: pixelSize - 2,
          color: '#ff7fb7',
          target: null
        });
      }
    }
  }
}
buildInitialParticles();

// create target positions forming a larger heart (parametric)
function buildHeartTargets(n) {
  const targets = [];
  const scale = Math.min(innerWidth, innerHeight) * 0.22;
  for (let i=0;i<n;i++) {
    const t = (i / n) * Math.PI * 2;
    // classic heart parametric (scaled)
    const x = 16 * Math.pow(Math.sin(t),3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    targets.push({ x: center.x + x * (scale/32), y: center.y - y * (scale/32) });
  }
  return targets;
}

// particle behaviors
function explodeParticles() {
  phase = 'exploded';
  particles.forEach(p => {
    const angle = Math.atan2(p.y - center.y, p.x - center.x) + rand(-0.6,0.6);
    const speed = rand(4,12);
    p.vx = Math.cos(angle) * speed;
    p.vy = Math.sin(angle) * speed - rand(0,6);
  });
  // after short time, move to forming
  setTimeout(() => {
    startForming();
  }, 700);
}

function startForming() {
  phase = 'forming';
  // compute targets: sample enough points
  const targets = buildHeartTargets(particles.length);
  // shuffle targets a bit and assign
  for (let i=0;i<particles.length;i++) {
    const t = targets[i % targets.length];
    particles[i].target = { x: t.x + rand(-4,4), y: t.y + rand(-4,4) };
  }
  // slow velocities
  particles.forEach(p => { p.vx = rand(-1.2,1.2); p.vy = rand(-1.2,1.2); });
  // after they settle, show door
  setTimeout(()=> {
    phase = 'formed';
    showDoor();
  }, 1600);
}

function showDoor() {
  phase = 'doorShown';
  const door = document.getElementById('door');
  door.style.display = 'block';
  // pop-in
  setTimeout(()=> door.style.transform = 'translate(-50%,-50%) scale(1)',10);
}

// animation loop
let last = performance.now();
function update(dt) {
  // update particles
  if (phase === 'idle') {
    // slight shimmer
    particles.forEach(p => {
      p.x += Math.sin((p.x+p.y+Date.now()/200)/100) * 0.2;
    });
  } else if (phase === 'exploded') {
    particles.forEach(p => {
      p.vy += 0.3; // gravity
      p.x += p.vx;
      p.y += p.vy;
      p.size *= 0.995;
      p.vx *= 0.98;
      p.vy *= 0.99;
    });
  } else if (phase === 'forming' || phase === 'formed') {
    // move toward targets
    particles.forEach(p => {
      if (!p.target) return;
      const dx = p.target.x - p.x;
      const dy = p.target.y - p.y;
      p.vx += dx * 0.02;
      p.vy += dy * 0.02;
      // damping
      p.vx *= 0.85;
      p.vy *= 0.85;
      p.x += p.vx;
      p.y += p.vy;
    });
  } else if (phase === 'finale') {
    // finale handled by extra particles; keep drawn
    particles.forEach(p => {
      p.x += p.vx; p.y += p.vy;
      p.vy += 0.12;
      p.size *= 0.995;
    });
  }
}

function draw() {
  // clear
  ctx.clearRect(0,0,innerWidth, innerHeight);
  // draw background faint hearts? keep simple
  // draw particles as pixel squares (pixel look)
  particles.forEach(p => {
    ctx.fillStyle = p.color;
    // pixel look: round to integer positions
    const s = Math.max(1, p.size);
    ctx.fillRect(Math.round(p.x - s/2), Math.round(p.y - s/2), Math.round(s), Math.round(s));
  });
}

// main loop
function loop(now) {
  const dt = now - last;
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// handle initial click on canvas (only once)
let clicked = false;
canvas.addEventListener('click', (e) => {
  if (clicked) return;
  // check if clicked near center heart region
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const d = Math.hypot(mx - center.x, my - center.y);
  if (d < initialHeartScale * 0.9) {
    clicked = true;
    document.getElementById('hint').style.opacity = 0;
    explodeParticles();
  }
});

// door click and knock sound
const door = document.getElementById('door');
door.addEventListener('click', async (ev) => {
  if (phase !== 'doorShown' && phase !== 'formed') return;
  // play knock sound via WebAudio (short knock)
  playKnock();
  // animate door opening: apply class
  door.classList.add('opening');
  // after open, show emoji
  setTimeout(() => {
    phase = 'doorOpen';
    doEmojiEntrance();
    // hide door after short delay
    setTimeout(()=> {
      door.style.display = 'none';
    }, 900);
  }, 400); // small delay while playing knock
});

function playKnock() {
  try {
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    // two knocks
    const t0 = ac.currentTime;
    for (let i=0;i<2;i++) {
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = 'square';
      o.frequency.value = 600 - i*120;
      g.gain.value = 0.0001;
      g.gain.linearRampToValueAtTime(0.12, t0 + i*0.05);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + i*0.25);
      o.connect(g); g.connect(ac.destination);
      o.start(t0 + i*0.05);
      o.stop(t0 + i*0.3);
    }
  } catch(e) {
    // fallback: do nothing
  }
}

// emoji entrance
const emojiEl = document.getElementById('emoji');
function doEmojiEntrance() {
  // place emoji inside door position to start
  const doorRect = door.getBoundingClientRect();
  emojiEl.style.left = (doorRect.left + doorRect.width/2) + 'px';
  emojiEl.style.top = (doorRect.top + doorRect.height/2) + 'px';
  emojiEl.style.transform = 'translate(-50%,-50%) scale(1)';
  // animate moving to center then vanish door
  setTimeout(()=> {
    // move emoji to a bit above center
    emojiEl.style.left = (center.x) + 'px';
    emojiEl.style.top = (center.y - 40) + 'px';
  }, 120);
  // after reach center, show bubble
  setTimeout(()=> {
    emojiEl.style.transform = 'translate(-50%,-50%) scale(1.1)';
    showBubble();
  }, 900);
}

const bubble = document.getElementById('bubble');
function showBubble() {
  bubble.style.transform = 'translateX(-50%) scale(1)';
  bubble.style.display = 'block';
  const msg = "Bu senin iÃ§in bitanem.";
  // pixel-ish font: type fast
  let i = 0;
  bubble.textContent = '';
  function typeNext() {
    if (i < msg.length) {
      bubble.textContent += msg[i++];
      setTimeout(typeNext, 45); // hÄ±zlÄ±
    } else {
      // after typed, schedule finale
      setTimeout(()=> triggerFinale(), 9000); // ~9s sonra finale
    }
  }
  typeNext();
}

// Finale: pink explosion and show final text
function triggerFinale() {
  phase = 'finale';
  // create many pink particles outward from center
  particles = [];
  for (let i=0;i<350;i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = rand(2,14);
    particles.push({
      x: center.x,
      y: center.y,
      vx: Math.cos(angle)*speed + rand(-2,2),
      vy: Math.sin(angle)*speed + rand(-2,2),
      size: rand(6,14),
      color: `hsl(${rand(320,340)},100%,65%)`
    });
  }
  // show final text after short delay
  setTimeout(()=> {
    const ft = document.getElementById('finalText');
    ft.style.transform = 'translate(-50%,-50%) scale(1)';
  }, 600);
  // after a while freeze (stop animations)
  setTimeout(()=> {
    // fade bursting particles out
    particles.forEach(p => { p.vx*=0.3; p.vy*=0.3; p.size*=0.7; });
  }, 4000);
}

// responsive handle
window.addEventListener('resize', ()=> {
  W = canvas.width = innerWidth * DPR;
  H = canvas.height = innerHeight * DPR;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.scale(DPR, DPR);
  center.x = innerWidth/2;
  center.y = innerHeight/2;
});

// small tweak: fade hint after click
document.getElementById('hint').addEventListener('transitionend', ()=> {
  // nothing
});

/* initial gentle pulse for the central small heart (optional)
   we'll animate pixel brightness in draw loop via colors, but keep simple */
</script>
</body>
</html>
